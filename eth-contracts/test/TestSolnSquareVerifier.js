// import SquareVerifier solidity contract generated by Zokrates
let SquareVerifier = artifacts.require('SquareVerifier');
let SolnSquareVerifier = artifacts.require('SolnSquareVerifier');

// import correct proof and inputs generated by Zokrates
let squareProof = require('../../zokrates/code/square/proof.json');

contract('TestSolnSquareVerifier', accounts => {

    const contract_owner = accounts[0];
    const account_one = accounts[1];

    describe('Test that new solution can be added for contract', function(){

        beforeEach(async function () {
            let verifier = await SquareVerifier.new({from: contract_owner});
            this.contract = await SolnSquareVerifier.new(verifier.address, {from: contract_owner});
        })

        it('ERC721 token can be minted for contract provided new solution', async function () {

            await this.contract.proveMint(account_one, 1011, squareProof.proof.a, squareProof.proof.b, squareProof.proof.c, squareProof.inputs, {from: contract_owner});

            // Declare and Initialize a variable for event
            let addedSolutionEventEmitted = false;

            // Watch the emitted event AddedSolution()
            await this.contract.AddedSolution((err, res) => addedSolutionEventEmitted = true);

            assert.equal(addedSolutionEventEmitted, true, 'Invalid event emitted');
        })

    });

    describe('Test ERC721 token can be minted for contract', function(){

        beforeEach(async function () {
            let verifier = await SquareVerifier.new({from: contract_owner});
            this.contract = await SolnSquareVerifier.new(verifier.address, {from: contract_owner});
        })

        it('ERC721 token can be minted for contract provided new solution', async function () {
            let minted1 = true;
            let minted2 = true;

            // Mint token with new solution
            try {
                  await this.contract.proveMint(account_one, 1011, squareProof.proof.a, squareProof.proof.b, squareProof.proof.c, squareProof.inputs, {from: contract_owner});
                } catch (error) {
                  //console.log(error.reason);
                  minted1 = false;
                }

            // Mint token with existing solution
            try {
                  await this.contract.proveMint(account_one, 1012, squareProof.proof.a, squareProof.proof.b, squareProof.proof.c, squareProof.inputs, {from: contract_owner});
                } catch (error) {
                  //console.log(error.reason);
                  minted2 = false;
                }

            let tokenTotalSupply = await this.contract.totalSupply.call();

            assert.equal(minted1, true, "Token did not succeed using new solution");
            assert.equal(minted2, false, "Token did not fail using existing solution");
            assert.equal(tokenTotalSupply.toNumber(), 1, "Incorrect total token supply count");
        })

    });
})